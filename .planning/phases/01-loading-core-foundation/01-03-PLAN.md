---
phase: 01-loading-core-foundation
plan: 03
type: execute
wave: 3
depends_on: [01, 02]
files_modified:
  - src/app/providers/AppProviders.tsx
  - src/app/router/AppRouter.tsx
  - src/shared/auth/AuthContext.tsx
  - src/shared/loading/AppLoadingBridge.tsx
  - src/shared/loading/index.ts
  - src/app/router/AppRouter.loading.test.tsx
autonomous: true
requirements: [LOAD-01, LOAD-04]
user_setup: []
must_haves:
  truths:
    - "App root renders loading infrastructure from one shared provider/component path."
    - "Base auth and route fallback wiring uses canonical loading surface instead of local variants."
    - "Every integrated loading start path has explicit stop/cleanup semantics."
  artifacts:
    - path: src/app/providers/AppProviders.tsx
      provides: root provider integration for loading system
      min_lines: 20
    - path: src/shared/loading/AppLoadingBridge.tsx
      provides: adapter wiring from existing auth/router state into loading contract
      min_lines: 60
    - path: src/app/router/AppRouter.tsx
      provides: replacement of RouteFallback with shared loading surface path
      min_lines: 300
  key_links:
    - from: src/app/providers/AppProviders.tsx
      to: src/shared/loading/LoadingProvider.tsx
      via: provider mount order includes global loading context
    - from: src/shared/loading/AppLoadingBridge.tsx
      to: src/app/router/AppRouter.tsx
      via: route/auth loading events map into loading lifecycle API
---

<objective>
Wire the loading foundation into the app shell and replace baseline divergent fallbacks.

Purpose: Ensure Phase 1 ships usable infrastructure in the running app, not only isolated provider/component primitives.
Output: App root integration and canonical fallback wiring across base auth/router paths.
</objective>

<execution_context>
@/Users/tillschafer/.codex/get-shit-done/workflows/execute-plan.md
@/Users/tillschafer/.codex/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-loading-core-foundation/01-CONTEXT.md
@.planning/phases/01-loading-core-foundation/01-RESEARCH.md
@src/app/providers/AppProviders.tsx
@src/app/router/AppRouter.tsx
@src/shared/auth/AuthContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Mount loading provider and canonical screen in app root</name>
  <files>
    src/app/providers/AppProviders.tsx
    src/shared/loading/index.ts
  </files>
  <action>
    Integrate `LoadingProvider` and `FullPageLoadingScreen` into root provider composition in a deterministic order with existing `AuthProvider`, `ToastProvider`, and `ProgressProvider`.
    Ensure loading overlay z-index and render placement preserve toast visibility expectations for failure messaging.
  </action>
  <verify>
    <automated>npm run typecheck</automated>
  </verify>
  <done>All routes/pages are now under global loading provider and canonical screen render path exists at root.</done>
</task>

<task type="auto">
  <name>Task 2: Replace baseline route/auth fallback wiring with loading bridge</name>
  <files>
    src/shared/loading/AppLoadingBridge.tsx
    src/app/router/AppRouter.tsx
    src/shared/auth/AuthContext.tsx
  </files>
  <action>
    Remove direct use of local `RouteFallback` variant and bridge existing loading triggers into shared loading lifecycle.
    Required outcomes:
    - auth bootstrapping/loading path uses global loading contract
    - route lazy fallback path no longer owns separate loading UI implementation
    - error and cancellation paths call lifecycle cleanup through shared contract (including `finally` paths)
    Keep scope to baseline shell wiring; broad route/auth transition coverage remains for phase 2.
  </action>
  <verify>
    <automated>npm run typecheck && npm run lint</automated>
  </verify>
  <done>App shell no longer renders divergent local full-page fallback variants for the base loading paths addressed in phase 1.</done>
</task>

<task type="auto">
  <name>Task 3: Add integration-focused regression test for canonical fallback wiring</name>
  <files>src/app/router/AppRouter.loading.test.tsx</files>
  <action>
    Add targeted test coverage that asserts:
    - loading shell uses shared full-page component path
    - route/auth loading path no longer renders old `RouteFallback` copy strings
    - cleanup after rejected async operation clears active loading state
  </action>
  <verify>
    <automated>npm run test -- src/app/router/AppRouter.loading.test.tsx</automated>
  </verify>
  <done>Base shell integration is regression-protected for canonical loading wiring and lifecycle cleanup expectations.</done>
</task>

</tasks>

<verification>
Foundation components are mounted in the real app and baseline fallback wiring is unified under the centralized lifecycle contract.
</verification>

<success_criteria>
- [ ] Loading provider is mounted at app root and full-page loading screen is rendered from shared infrastructure.
- [ ] Baseline route/auth fallback wiring no longer uses divergent local full-page loading variants.
- [ ] Integrated loading starts are cleaned up via centralized lifecycle contract.
- [ ] Integration tests validate canonical wiring and cleanup behavior.
</success_criteria>

<output>
After completion, create `.planning/phases/01-loading-core-foundation/01-03-SUMMARY.md`
</output>
