---
phase: 01-loading-core-foundation
plan: 05
type: execute
wave: 2
depends_on: [04]
gap_closure: true
files_modified:
  - src/apps/busflow/BusflowApp.tsx
  - src/apps/busflow/hooks/useBusflowData.ts
  - src/shared/loading/AppLoadingBridge.tsx
  - src/app/router/AppRouter.loading.test.tsx
autonomous: true
requirements: [FLOW-01, FLOW-02, QUAL-01]
user_setup: []
must_haves:
  truths:
    - "BusFlow navigation/data bootstrapping never renders a second legacy full-page loader variant."
    - "Route and feature data loading paths are bridged to the shared loading lifecycle, preserving cleanup on settle/error."
    - "Legacy copy `Lade BusFlow Daten...` is removed from active loading UI paths."
  artifacts:
    - path: src/apps/busflow/BusflowApp.tsx
      provides: removal of legacy local loading screen branch
      min_lines: 300
    - path: src/apps/busflow/hooks/useBusflowData.ts
      provides: loading state integration strategy compatible with shared loading contract
      min_lines: 80
    - path: src/app/router/AppRouter.loading.test.tsx
      provides: regression coverage for canonical-only loader usage
      min_lines: 80
  key_links:
    - from: src/apps/busflow/BusflowApp.tsx
      to: src/shared/loading/AppLoadingBridge.tsx
      via: BusFlow-specific loading signals flow through shared token lifecycle
    - from: src/apps/busflow/hooks/useBusflowData.ts
      to: src/shared/loading/LoadingProvider.tsx
      via: async data bootstrapping uses centralized loading start/stop semantics
---

<objective>
Eliminate mixed legacy/canonical loading behavior in BusFlow route flows.

Purpose: Ensure users see exactly one loading system across route transitions and app data hydration.
Output: BusFlow loading paths migrated to shared loading lifecycle plus integration tests preventing legacy fallback reintroduction.
</objective>

<execution_context>
@/Users/tillschafer/.codex/get-shit-done/workflows/execute-plan.md
@/Users/tillschafer/.codex/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-loading-core-foundation/01-UAT.md
@src/apps/busflow/BusflowApp.tsx
@src/apps/busflow/hooks/useBusflowData.ts
@src/app/router/AppRouter.tsx
@src/shared/loading/AppLoadingBridge.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove BusFlow-local full-screen legacy loader branch</name>
  <files>src/apps/busflow/BusflowApp.tsx</files>
  <action>
    Delete or refactor the `if (loading)` branch that renders the standalone `Leaf` + `Lade BusFlow Daten...` screen.
    Keep page behavior safe by retaining data guards/empty-state handling, but delegate visible blocking loader responsibility to the canonical global loading surface.
  </action>
  <verify>
    <automated>npm run typecheck</automated>
  </verify>
  <done>No route into BusFlow renders a second full-page loading variant.</done>
</task>

<task type="auto">
  <name>Task 2: Bridge BusFlow bootstrap loading into shared lifecycle API</name>
  <files>
    src/apps/busflow/hooks/useBusflowData.ts
    src/shared/loading/AppLoadingBridge.tsx
  </files>
  <action>
    Integrate BusFlow data bootstrap loading with the global loading manager:
    - use scoped shared loading tokens or `runWithLoading` wrapper for BusFlow data fetch sequence
    - guarantee stop/cleanup on success and error paths
    - keep hook API stable enough for existing consumers while removing UI coupling to local loader rendering
  </action>
  <verify>
    <automated>npm run typecheck && npm run lint</automated>
  </verify>
  <done>BusFlow startup loading contributes to global canonical loader state and always settles cleanly.</done>
</task>

<task type="auto">
  <name>Task 3: Add integration regression coverage for canonical-only loader behavior</name>
  <files>src/app/router/AppRouter.loading.test.tsx</files>
  <action>
    Extend integration tests to ensure:
    - legacy `Lade BusFlow Daten...` copy is absent in route/bootstrap loading flows
    - only canonical full-page loader is visible for loading transitions
    - cleanup after resolve/reject still removes active loading tokens
  </action>
  <verify>
    <automated>npm run test -- src/app/router/AppRouter.loading.test.tsx</automated>
  </verify>
  <done>Test suite fails if a second route-local loader variant is reintroduced.</done>
</task>

</tasks>

<verification>
BusFlow loading no longer bypasses the canonical loading system; route transitions remain visually and behaviorally consistent.
</verification>

<success_criteria>
- [ ] Legacy `Lade BusFlow Daten...` full-screen loader path is removed.
- [ ] BusFlow bootstrap loading is managed by shared loading lifecycle.
- [ ] Integration tests enforce canonical single-loader behavior.
- [ ] Typecheck/lint/tests pass for modified paths.
</success_criteria>

<output>
After completion, create `.planning/phases/01-loading-core-foundation/01-05-SUMMARY.md`
</output>
