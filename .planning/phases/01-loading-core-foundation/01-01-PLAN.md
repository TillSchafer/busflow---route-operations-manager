---
phase: 01-loading-core-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shared/loading/loading-types.ts
  - src/shared/loading/loading-engine.ts
  - src/shared/loading/LoadingProvider.tsx
  - src/shared/loading/index.ts
  - src/shared/loading/LoadingProvider.test.tsx
autonomous: true
requirements: [LOAD-04, LOAD-02]
user_setup: []
must_haves:
  truths:
    - "Starting tracked async work always has a safe stop path, including thrown errors."
    - "Overlapping async operations keep global loading active until the final operation settles."
    - "Reveal delay is centrally controlled at 150ms and can be canceled before display."
  artifacts:
    - path: src/shared/loading/loading-engine.ts
      provides: token/ref-count lifecycle manager
      min_lines: 80
    - path: src/shared/loading/LoadingProvider.tsx
      provides: React context bridge to loading engine
      min_lines: 80
    - path: src/shared/loading/LoadingProvider.test.tsx
      provides: lifecycle cleanup and concurrency coverage
      min_lines: 60
  key_links:
    - from: src/shared/loading/LoadingProvider.tsx
      to: src/shared/loading/loading-engine.ts
      via: provider delegates start/stop/runWithLoading to engine
    - from: src/shared/loading/LoadingProvider.test.tsx
      to: src/shared/loading/LoadingProvider.tsx
      via: tests assert success/error/concurrency lifecycle behavior
---

<objective>
Build the core loading lifecycle contract for the platform.

Purpose: Establish one centralized async lifecycle API before UI/wiring work so cleanup behavior is guaranteed and reusable.
Output: A token-based loading engine with provider + hook exports and contract-focused tests.
</objective>

<execution_context>
@/Users/tillschafer/.codex/get-shit-done/workflows/execute-plan.md
@/Users/tillschafer/.codex/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-loading-core-foundation/01-CONTEXT.md
@.planning/phases/01-loading-core-foundation/01-RESEARCH.md
@src/shared/components/ProgressProvider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define loading contracts and token lifecycle engine</name>
  <files>
    src/shared/loading/loading-types.ts
    src/shared/loading/loading-engine.ts
  </files>
  <action>
    Create typed contracts for loading scope/message/metadata and implement a loading engine that issues unique tokens for each start call.
    Engine responsibilities:
    - track active tokens and operation metadata
    - expose derived active count and visibility-ready state
    - implement 150ms reveal delay scheduling with cancelation when active count returns to zero
    - provide idempotent stop(token) so duplicate stop calls do not corrupt state
    - expose runWithLoading(asyncFn, options) that always executes stop in finally
  </action>
  <verify>
    <automated>npm run typecheck</automated>
  </verify>
  <done>Engine API supports start/stop/runWithLoading with deterministic concurrency-safe behavior and no direct UI dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Implement LoadingProvider and useLoading hook</name>
  <files>
    src/shared/loading/LoadingProvider.tsx
    src/shared/loading/index.ts
  </files>
  <action>
    Add React provider that wraps the loading engine and exposes context methods and state to consumers:
    - start, stop, runWithLoading
    - isActive, shouldReveal, activeCount
    - current display payload (message, optional progress, scope)
    Keep message fallback behavior aligned to `Lade...` and preserve full-block semantics through state fields consumed by plan 02 UI.
    Export stable public API from `src/shared/loading/index.ts`.
  </action>
  <verify>
    <automated>npm run typecheck</automated>
  </verify>
  <done>Loading provider can be mounted at app root and accessed with a guarded `useLoading` hook without runtime context errors.</done>
</task>

<task type="auto">
  <name>Task 3: Add provider contract tests for cleanup and overlap behavior</name>
  <files>src/shared/loading/LoadingProvider.test.tsx</files>
  <action>
    Create targeted Vitest/RTL tests that validate:
    - `runWithLoading` cleans up on success and thrown error
    - overlapping operations keep active state until final stop
    - reveal delay timer cancels when operation settles before 150ms
    Keep tests fast and deterministic with fake timers where needed.
  </action>
  <verify>
    <automated>npm run test -- src/shared/loading/LoadingProvider.test.tsx</automated>
  </verify>
  <done>Tests prove lifecycle safety contract and delay behavior baseline before UI integration.</done>
</task>

</tasks>

<verification>
Global loading lifecycle is contract-tested for success/error overlap flows and exposes stable provider API for downstream UI and integration plans.
</verification>

<success_criteria>
- [ ] Loading engine tracks start/stop with token ownership and overlap safety.
- [ ] `runWithLoading` guarantees cleanup in `finally`.
- [ ] Reveal delay defaults to 150ms and is cancelable.
- [ ] Provider + hook API is exported for app-level wiring.
- [ ] Contract test suite passes for lifecycle edge cases.
</success_criteria>

<output>
After completion, create `.planning/phases/01-loading-core-foundation/01-01-SUMMARY.md`
</output>
