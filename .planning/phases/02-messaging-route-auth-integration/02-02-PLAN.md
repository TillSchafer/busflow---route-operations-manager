---
phase: 02-messaging-route-auth-integration
plan: 02
type: execute
wave: 2
depends_on: [01]
files_modified:
  - src/shared/loading/AppLoadingBridge.tsx
  - src/app/router/AppRouter.tsx
  - src/app/router/AppRouter.loading.test.tsx
autonomous: true
requirements: [FLOW-01, LOAD-03]
user_setup: []
must_haves:
  truths:
    - "Route/lazy transitions use shared loading manager with registry-backed message keys."
    - "Route transition fallback continues to render only one canonical loading UI path."
  artifacts:
    - path: src/shared/loading/AppLoadingBridge.tsx
      provides: route fallback emits scoped message key signals
      min_lines: 55
    - path: src/app/router/AppRouter.tsx
      provides: router suspense fallback wiring to message-key route policy
      min_lines: 300
    - path: src/app/router/AppRouter.loading.test.tsx
      provides: route integration regression for canonical loading path
      min_lines: 70
  key_links:
    - from: src/app/router/AppRouter.tsx
      to: src/shared/loading/AppLoadingBridge.tsx
      via: suspense fallback starts route-scoped loading token via bridge component
---

<objective>
Standardize route/lazy transition loading via message-key policy.

Purpose: Keep route transitions on one canonical loading pipeline while using scoped copy policy.
Output: Router + route fallback bridge updated to message-key usage with regression checks.
</objective>

<execution_context>
@/Users/tillschafer/.codex/get-shit-done/workflows/execute-plan.md
@/Users/tillschafer/.codex/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-messaging-route-auth-integration/02-01-SUMMARY.md
@src/shared/loading/AppLoadingBridge.tsx
@src/app/router/AppRouter.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Route fallback bridge emits message keys</name>
  <files>src/shared/loading/AppLoadingBridge.tsx</files>
  <action>
    Update `RouteLoadingFallback` to prefer route-scoped message keys (rather than hardcoded copy) while keeping optional explicit message override support.
    Ensure start/stop lifecycle behavior remains unchanged.
  </action>
  <verify>
    <automated>npm run typecheck</automated>
  </verify>
  <done>Route fallback can drive canonical loader copy through shared message-key policy.</done>
</task>

<task type="auto">
  <name>Task 2: Wire AppRouter suspense fallback to message-key route policy</name>
  <files>src/app/router/AppRouter.tsx</files>
  <action>
    Update AppRouter suspense fallback wiring to use new route message-key behavior and remove redundant hardcoded fallback strings where registry policy should apply.
  </action>
  <verify>
    <automated>npm run typecheck && npm run lint</automated>
  </verify>
  <done>Lazy-route transitions use unified loading copy policy through shared route fallback bridge.</done>
</task>

<task type="auto">
  <name>Task 3: Extend route loading integration regression tests</name>
  <files>src/app/router/AppRouter.loading.test.tsx</files>
  <action>
    Add assertions that route loading path still:
    - uses shared loading manager and canonical full-page screen
    - avoids legacy fallback copy variants
    - resolves default fallback `Lade...` when no explicit message is provided
  </action>
  <verify>
    <automated>npm run test -- src/app/router/AppRouter.loading.test.tsx</automated>
  </verify>
  <done>Route loading integration is regression-protected for canonical + scoped-message behavior.</done>
</task>

</tasks>

<verification>
Route/lazy transitions are consistently driven by shared loading manager and message policy.
</verification>

<success_criteria>
- [ ] Route fallback uses message-key loading policy.
- [ ] AppRouter suspense path has no hardcoded divergent fallback copy.
- [ ] Route loading integration tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/02-messaging-route-auth-integration/02-02-SUMMARY.md`
</output>
