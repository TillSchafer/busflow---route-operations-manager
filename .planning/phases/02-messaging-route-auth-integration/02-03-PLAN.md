---
phase: 02-messaging-route-auth-integration
plan: 03
type: execute
wave: 2
depends_on: [01]
files_modified:
  - src/shared/loading/AppLoadingBridge.tsx
  - src/app/router/AppRouter.tsx
  - src/shared/loading/AppLoadingBridge.test.tsx
autonomous: true
requirements: [FLOW-02, LOAD-03]
user_setup: []
must_haves:
  truths:
    - "Auth/session hydration uses shared loading bridge with scoped message-key defaults."
    - "Auth loading tokens are cleaned up on settle and unmount across route/auth states."
  artifacts:
    - path: src/shared/loading/AppLoadingBridge.tsx
      provides: auth bridge message-key policy + cleanup-safe lifecycle behavior
      min_lines: 70
    - path: src/app/router/AppRouter.tsx
      provides: auth loading bridge usage aligned with message-key policy
      min_lines: 300
    - path: src/shared/loading/AppLoadingBridge.test.tsx
      provides: auth/route bridge lifecycle cleanup coverage
      min_lines: 80
  key_links:
    - from: src/app/router/AppRouter.tsx
      to: src/shared/loading/AppLoadingBridge.tsx
      via: auth loading state maps into global loading lifecycle with keyed fallback copy
---

<objective>
Harden auth/session hydration integration on shared loading message policy.

Purpose: Ensure auth bootstrap stays on canonical loading behavior with lifecycle-safe cleanup.
Output: Auth bridge + router wiring + focused lifecycle tests for auth loading.
</objective>

<execution_context>
@/Users/tillschafer/.codex/get-shit-done/workflows/execute-plan.md
@/Users/tillschafer/.codex/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-messaging-route-auth-integration/02-01-SUMMARY.md
@src/shared/loading/AppLoadingBridge.tsx
@src/app/router/AppRouter.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auth bridge message-key policy defaults</name>
  <files>src/shared/loading/AppLoadingBridge.tsx</files>
  <action>
    Update `AppLoadingBridge` auth path to emit scoped auth message keys by default while preserving explicit message override compatibility.
    Keep start/stop idempotent and unmount cleanup semantics intact.
  </action>
  <verify>
    <automated>npm run typecheck</automated>
  </verify>
  <done>Auth loading bridge emits policy-driven copy and retains lifecycle safety.</done>
</task>

<task type="auto">
  <name>Task 2: Align AppRouter auth bridge usage with policy defaults</name>
  <files>src/app/router/AppRouter.tsx</files>
  <action>
    Ensure AppRouter auth loading wiring uses shared auth bridge defaults (no duplicated copy strings for auth bootstrap paths), while preserving existing auth flow behavior.
  </action>
  <verify>
    <automated>npm run typecheck && npm run lint</automated>
  </verify>
  <done>Auth/session hydration path is fully driven through shared loading policy and bridge contract.</done>
</task>

<task type="auto">
  <name>Task 3: Add auth loading bridge lifecycle tests</name>
  <files>src/shared/loading/AppLoadingBridge.test.tsx</files>
  <action>
    Add tests validating:
    - auth loading true/false transitions start and stop tokens correctly
    - unmount cleanup clears active token
    - default fallback copy resolves to `Lade...` through message policy when no explicit message is set
  </action>
  <verify>
    <automated>npm run test -- src/shared/loading/AppLoadingBridge.test.tsx</automated>
  </verify>
  <done>Auth bridge behavior is regression-protected for message policy + cleanup lifecycle.</done>
</task>

</tasks>

<verification>
Auth/session hydration now consistently uses shared loading manager semantics and scoped message policy.
</verification>

<success_criteria>
- [ ] Auth loading bridge defaults to policy-driven keyed message behavior.
- [ ] AppRouter auth paths avoid hardcoded divergent loading copy.
- [ ] Auth bridge lifecycle tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/02-messaging-route-auth-integration/02-03-SUMMARY.md`
</output>
